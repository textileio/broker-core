// Code generated by sqlc. DO NOT EDIT.
// source: auction_deal.sql

package db

import (
	"context"
	"time"

	"github.com/textileio/bidbot/lib/auction"
	"github.com/textileio/broker-core/broker"
)

const createAuctionDeal = `-- name: CreateAuctionDeal :exec
INSERT INTO auction_deals(
batch_id,
storage_provider_id,
price_per_gib_per_epoch,
start_epoch,
verified,
fast_retrieval,
auction_id,
bid_id,
status,
executing,
error_cause,
retries,
proposal_cid,
deal_id,
deal_expiration,
deal_market_status,
ready_at
    ) VALUES(
      $1,
      $2,
      $3,
      $4,
      $5,
      $6,
      $7,
      $8,
      $9,
      $10,
      $11,
      $12,
      $13,
      $14,
      $15,
      $16,
      $17
      )
`

type CreateAuctionDealParams struct {
	BatchID             broker.BatchID `json:"batchID"`
	StorageProviderID   string         `json:"storageProviderID"`
	PricePerGibPerEpoch int64          `json:"pricePerGibPerEpoch"`
	StartEpoch          uint64         `json:"startEpoch"`
	Verified            bool           `json:"verified"`
	FastRetrieval       bool           `json:"fastRetrieval"`
	AuctionID           auction.ID     `json:"auctionID"`
	BidID               auction.BidID  `json:"bidID"`
	Status              Status         `json:"status"`
	Executing           bool           `json:"executing"`
	ErrorCause          string         `json:"errorCause"`
	Retries             int            `json:"retries"`
	ProposalCid         string         `json:"proposalCid"`
	DealID              int64          `json:"dealID"`
	DealExpiration      uint64         `json:"dealExpiration"`
	DealMarketStatus    uint64         `json:"dealMarketStatus"`
	ReadyAt             time.Time      `json:"readyAt"`
}

func (q *Queries) CreateAuctionDeal(ctx context.Context, arg CreateAuctionDealParams) error {
	_, err := q.exec(ctx, q.createAuctionDealStmt, createAuctionDeal,
		arg.BatchID,
		arg.StorageProviderID,
		arg.PricePerGibPerEpoch,
		arg.StartEpoch,
		arg.Verified,
		arg.FastRetrieval,
		arg.AuctionID,
		arg.BidID,
		arg.Status,
		arg.Executing,
		arg.ErrorCause,
		arg.Retries,
		arg.ProposalCid,
		arg.DealID,
		arg.DealExpiration,
		arg.DealMarketStatus,
		arg.ReadyAt,
	)
	return err
}

const getAuctionDeal = `-- name: GetAuctionDeal :one
SELECT storage_provider_id, price_per_gib_per_epoch, start_epoch, verified, fast_retrieval, auction_id, bid_id, status, executing, error_cause, retries, proposal_cid, deal_id, deal_expiration, deal_market_status, ready_at, created_at, updated_at, batch_id FROM auction_deals WHERE auction_id = $1 AND storage_provider_id = $2
`

type GetAuctionDealParams struct {
	AuctionID         auction.ID `json:"auctionID"`
	StorageProviderID string     `json:"storageProviderID"`
}

func (q *Queries) GetAuctionDeal(ctx context.Context, arg GetAuctionDealParams) (AuctionDeal, error) {
	row := q.queryRow(ctx, q.getAuctionDealStmt, getAuctionDeal, arg.AuctionID, arg.StorageProviderID)
	var i AuctionDeal
	err := row.Scan(
		&i.StorageProviderID,
		&i.PricePerGibPerEpoch,
		&i.StartEpoch,
		&i.Verified,
		&i.FastRetrieval,
		&i.AuctionID,
		&i.BidID,
		&i.Status,
		&i.Executing,
		&i.ErrorCause,
		&i.Retries,
		&i.ProposalCid,
		&i.DealID,
		&i.DealExpiration,
		&i.DealMarketStatus,
		&i.ReadyAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BatchID,
	)
	return i, err
}

const getAuctionDealIDs = `-- name: GetAuctionDealIDs :many
SELECT auction_id, storage_provider_id FROM auction_deals WHERE batch_id = $1
`

type GetAuctionDealIDsRow struct {
	AuctionID         auction.ID `json:"auctionID"`
	StorageProviderID string     `json:"storageProviderID"`
}

func (q *Queries) GetAuctionDealIDs(ctx context.Context, batchID broker.BatchID) ([]GetAuctionDealIDsRow, error) {
	rows, err := q.query(ctx, q.getAuctionDealIDsStmt, getAuctionDealIDs, batchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAuctionDealIDsRow
	for rows.Next() {
		var i GetAuctionDealIDsRow
		if err := rows.Scan(&i.AuctionID, &i.StorageProviderID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuctionDealsByStatus = `-- name: GetAuctionDealsByStatus :many
SELECT storage_provider_id, price_per_gib_per_epoch, start_epoch, verified, fast_retrieval, auction_id, bid_id, status, executing, error_cause, retries, proposal_cid, deal_id, deal_expiration, deal_market_status, ready_at, created_at, updated_at, batch_id FROM auction_deals WHERE status = $1
`

func (q *Queries) GetAuctionDealsByStatus(ctx context.Context, status Status) ([]AuctionDeal, error) {
	rows, err := q.query(ctx, q.getAuctionDealsByStatusStmt, getAuctionDealsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuctionDeal
	for rows.Next() {
		var i AuctionDeal
		if err := rows.Scan(
			&i.StorageProviderID,
			&i.PricePerGibPerEpoch,
			&i.StartEpoch,
			&i.Verified,
			&i.FastRetrieval,
			&i.AuctionID,
			&i.BidID,
			&i.Status,
			&i.Executing,
			&i.ErrorCause,
			&i.Retries,
			&i.ProposalCid,
			&i.DealID,
			&i.DealExpiration,
			&i.DealMarketStatus,
			&i.ReadyAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BatchID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nextPendingAuctionDeal = `-- name: NextPendingAuctionDeal :one
UPDATE auction_deals
SET executing = TRUE,
    updated_at = CURRENT_TIMESTAMP
WHERE id = (SELECT id FROM auction_deals
    WHERE auction_deals.status = $1 AND
          (
            (auction_deals.ready_at < CURRENT_TIMESTAMP AND NOT auction_deals.executing) OR
            (auction_deals.executing AND extract(epoch from current_timestamp - auction_deals.updated_at) > $2::bigint)
   	  )
    ORDER BY auction_deals.ready_at asc
    FOR UPDATE SKIP LOCKED
    LIMIT 1)
RETURNING storage_provider_id, price_per_gib_per_epoch, start_epoch, verified, fast_retrieval, auction_id, bid_id, status, executing, error_cause, retries, proposal_cid, deal_id, deal_expiration, deal_market_status, ready_at, created_at, updated_at, batch_id
`

type NextPendingAuctionDealParams struct {
	Status       Status `json:"status"`
	StuckSeconds int64  `json:"stuckSeconds"`
}

func (q *Queries) NextPendingAuctionDeal(ctx context.Context, arg NextPendingAuctionDealParams) (AuctionDeal, error) {
	row := q.queryRow(ctx, q.nextPendingAuctionDealStmt, nextPendingAuctionDeal, arg.Status, arg.StuckSeconds)
	var i AuctionDeal
	err := row.Scan(
		&i.StorageProviderID,
		&i.PricePerGibPerEpoch,
		&i.StartEpoch,
		&i.Verified,
		&i.FastRetrieval,
		&i.AuctionID,
		&i.BidID,
		&i.Status,
		&i.Executing,
		&i.ErrorCause,
		&i.Retries,
		&i.ProposalCid,
		&i.DealID,
		&i.DealExpiration,
		&i.DealMarketStatus,
		&i.ReadyAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BatchID,
	)
	return i, err
}

const removeAuctionDeal = `-- name: RemoveAuctionDeal :exec
DELETE FROM auction_deals WHERE auction_id = $1 AND storage_provider_id = $2
`

type RemoveAuctionDealParams struct {
	AuctionID         auction.ID `json:"auctionID"`
	StorageProviderID string     `json:"storageProviderID"`
}

func (q *Queries) RemoveAuctionDeal(ctx context.Context, arg RemoveAuctionDealParams) error {
	_, err := q.exec(ctx, q.removeAuctionDealStmt, removeAuctionDeal, arg.AuctionID, arg.StorageProviderID)
	return err
}

const updateAuctionDeal = `-- name: UpdateAuctionDeal :execrows
UPDATE auction_deals
SET
    price_per_gib_per_epoch = $1,
    start_epoch = $2,
    verified = $3,
    fast_retrieval = $4,
    bid_id = $5,
    status = $6,
    executing = $7,
    error_cause = $8,
    retries = $9,
    proposal_cid = $10,
    deal_id = $11,
    deal_expiration = $12,
    deal_market_status = $13,
    ready_at = $14,
    updated_at = CURRENT_TIMESTAMP
    WHERE auction_id = $15 AND storage_provider_id = $16
`

type UpdateAuctionDealParams struct {
	PricePerGibPerEpoch int64         `json:"pricePerGibPerEpoch"`
	StartEpoch          uint64        `json:"startEpoch"`
	Verified            bool          `json:"verified"`
	FastRetrieval       bool          `json:"fastRetrieval"`
	BidID               auction.BidID `json:"bidID"`
	Status              Status        `json:"status"`
	Executing           bool          `json:"executing"`
	ErrorCause          string        `json:"errorCause"`
	Retries             int           `json:"retries"`
	ProposalCid         string        `json:"proposalCid"`
	DealID              int64         `json:"dealID"`
	DealExpiration      uint64        `json:"dealExpiration"`
	DealMarketStatus    uint64        `json:"dealMarketStatus"`
	ReadyAt             time.Time     `json:"readyAt"`
	AuctionID           auction.ID    `json:"auctionID"`
	StorageProviderID   string        `json:"storageProviderID"`
}

func (q *Queries) UpdateAuctionDeal(ctx context.Context, arg UpdateAuctionDealParams) (int64, error) {
	result, err := q.exec(ctx, q.updateAuctionDealStmt, updateAuctionDeal,
		arg.PricePerGibPerEpoch,
		arg.StartEpoch,
		arg.Verified,
		arg.FastRetrieval,
		arg.BidID,
		arg.Status,
		arg.Executing,
		arg.ErrorCause,
		arg.Retries,
		arg.ProposalCid,
		arg.DealID,
		arg.DealExpiration,
		arg.DealMarketStatus,
		arg.ReadyAt,
		arg.AuctionID,
		arg.StorageProviderID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
