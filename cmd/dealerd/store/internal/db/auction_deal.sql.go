// Code generated by sqlc. DO NOT EDIT.
// source: auction_deal.sql

package db

import (
	"context"
	"time"

	"github.com/textileio/bidbot/lib/auction"
)

const createAuctionDeal = `-- name: CreateAuctionDeal :exec
INSERT INTO auction_deals(
id,
auction_data_id,
storage_provider_id,
price_per_gib_per_epoch,
start_epoch,
verified,
fast_retrieval,
auction_id,
bid_id,
status,
executing,
error_cause,
retries,
proposal_cid,
deal_id,
deal_expiration,
deal_market_status,
ready_at
    ) VALUES(
      $1,
      $2,
      $3,
      $4,
      $5,
      $6,
      $7,
      $8,
      $9,
      $10,
      $11,
      $12,
      $13,
      $14,
      $15,
      $16,
      $17,
      $18
      )
`

type CreateAuctionDealParams struct {
	ID                  string        `json:"id"`
	AuctionDataID       string        `json:"auctionDataID"`
	StorageProviderID   string        `json:"storageProviderID"`
	PricePerGibPerEpoch int64         `json:"pricePerGibPerEpoch"`
	StartEpoch          uint64        `json:"startEpoch"`
	Verified            bool          `json:"verified"`
	FastRetrieval       bool          `json:"fastRetrieval"`
	AuctionID           auction.ID    `json:"auctionID"`
	BidID               auction.BidID `json:"bidID"`
	Status              Status        `json:"status"`
	Executing           bool          `json:"executing"`
	ErrorCause          string        `json:"errorCause"`
	Retries             int           `json:"retries"`
	ProposalCid         string        `json:"proposalCid"`
	DealID              int64         `json:"dealID"`
	DealExpiration      uint64        `json:"dealExpiration"`
	DealMarketStatus    uint64        `json:"dealMarketStatus"`
	ReadyAt             time.Time     `json:"readyAt"`
}

func (q *Queries) CreateAuctionDeal(ctx context.Context, arg CreateAuctionDealParams) error {
	_, err := q.exec(ctx, q.createAuctionDealStmt, createAuctionDeal,
		arg.ID,
		arg.AuctionDataID,
		arg.StorageProviderID,
		arg.PricePerGibPerEpoch,
		arg.StartEpoch,
		arg.Verified,
		arg.FastRetrieval,
		arg.AuctionID,
		arg.BidID,
		arg.Status,
		arg.Executing,
		arg.ErrorCause,
		arg.Retries,
		arg.ProposalCid,
		arg.DealID,
		arg.DealExpiration,
		arg.DealMarketStatus,
		arg.ReadyAt,
	)
	return err
}

const getAuctionDeal = `-- name: GetAuctionDeal :one
SELECT id, auction_data_id, storage_provider_id, price_per_gib_per_epoch, start_epoch, verified, fast_retrieval, auction_id, bid_id, status, executing, error_cause, retries, proposal_cid, deal_id, deal_expiration, deal_market_status, ready_at, created_at, updated_at FROM auction_deals WHERE id = $1
`

func (q *Queries) GetAuctionDeal(ctx context.Context, id string) (AuctionDeal, error) {
	row := q.queryRow(ctx, q.getAuctionDealStmt, getAuctionDeal, id)
	var i AuctionDeal
	err := row.Scan(
		&i.ID,
		&i.AuctionDataID,
		&i.StorageProviderID,
		&i.PricePerGibPerEpoch,
		&i.StartEpoch,
		&i.Verified,
		&i.FastRetrieval,
		&i.AuctionID,
		&i.BidID,
		&i.Status,
		&i.Executing,
		&i.ErrorCause,
		&i.Retries,
		&i.ProposalCid,
		&i.DealID,
		&i.DealExpiration,
		&i.DealMarketStatus,
		&i.ReadyAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAuctionDealIDs = `-- name: GetAuctionDealIDs :many
SELECT id FROM auction_deals WHERE auction_data_id = $1
`

func (q *Queries) GetAuctionDealIDs(ctx context.Context, auctionDataID string) ([]string, error) {
	rows, err := q.query(ctx, q.getAuctionDealIDsStmt, getAuctionDealIDs, auctionDataID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuctionDealsByStatus = `-- name: GetAuctionDealsByStatus :many
SELECT id, auction_data_id, storage_provider_id, price_per_gib_per_epoch, start_epoch, verified, fast_retrieval, auction_id, bid_id, status, executing, error_cause, retries, proposal_cid, deal_id, deal_expiration, deal_market_status, ready_at, created_at, updated_at FROM auction_deals WHERE status = $1
`

func (q *Queries) GetAuctionDealsByStatus(ctx context.Context, status Status) ([]AuctionDeal, error) {
	rows, err := q.query(ctx, q.getAuctionDealsByStatusStmt, getAuctionDealsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuctionDeal
	for rows.Next() {
		var i AuctionDeal
		if err := rows.Scan(
			&i.ID,
			&i.AuctionDataID,
			&i.StorageProviderID,
			&i.PricePerGibPerEpoch,
			&i.StartEpoch,
			&i.Verified,
			&i.FastRetrieval,
			&i.AuctionID,
			&i.BidID,
			&i.Status,
			&i.Executing,
			&i.ErrorCause,
			&i.Retries,
			&i.ProposalCid,
			&i.DealID,
			&i.DealExpiration,
			&i.DealMarketStatus,
			&i.ReadyAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nextPendingAuctionDeal = `-- name: NextPendingAuctionDeal :one
UPDATE auction_deals
SET executing = TRUE,
    updated_at = CURRENT_TIMESTAMP
WHERE id = (SELECT id FROM auction_deals
    WHERE auction_deals.ready_at < CURRENT_TIMESTAMP AND
          auction_deals.status=$1 AND
          NOT auction_deals.executing
    ORDER BY auction_deals.ready_at asc
    FOR UPDATE SKIP LOCKED
    LIMIT 1)
RETURNING id, auction_data_id, storage_provider_id, price_per_gib_per_epoch, start_epoch, verified, fast_retrieval, auction_id, bid_id, status, executing, error_cause, retries, proposal_cid, deal_id, deal_expiration, deal_market_status, ready_at, created_at, updated_at
`

func (q *Queries) NextPendingAuctionDeal(ctx context.Context, status Status) (AuctionDeal, error) {
	row := q.queryRow(ctx, q.nextPendingAuctionDealStmt, nextPendingAuctionDeal, status)
	var i AuctionDeal
	err := row.Scan(
		&i.ID,
		&i.AuctionDataID,
		&i.StorageProviderID,
		&i.PricePerGibPerEpoch,
		&i.StartEpoch,
		&i.Verified,
		&i.FastRetrieval,
		&i.AuctionID,
		&i.BidID,
		&i.Status,
		&i.Executing,
		&i.ErrorCause,
		&i.Retries,
		&i.ProposalCid,
		&i.DealID,
		&i.DealExpiration,
		&i.DealMarketStatus,
		&i.ReadyAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const removeAuctionDeal = `-- name: RemoveAuctionDeal :exec
DELETE FROM auction_deals WHERE id = $1
`

func (q *Queries) RemoveAuctionDeal(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.removeAuctionDealStmt, removeAuctionDeal, id)
	return err
}

const updateAuctionDeal = `-- name: UpdateAuctionDeal :execrows
UPDATE auction_deals
SET 
    auction_data_id = $1,
    storage_provider_id = $2,
    price_per_gib_per_epoch = $3,
    start_epoch = $4,
    verified = $5,
    fast_retrieval = $6,
    auction_id = $7,
    bid_id = $8,
    status = $9,
    executing = $10,
    error_cause = $11,
    retries = $12,
    proposal_cid = $13,
    deal_id = $14,
    deal_expiration = $15,
    deal_market_status = $16,
    ready_at = $17,
    updated_at = CURRENT_TIMESTAMP
    WHERE id = $18
`

type UpdateAuctionDealParams struct {
	AuctionDataID       string        `json:"auctionDataID"`
	StorageProviderID   string        `json:"storageProviderID"`
	PricePerGibPerEpoch int64         `json:"pricePerGibPerEpoch"`
	StartEpoch          uint64        `json:"startEpoch"`
	Verified            bool          `json:"verified"`
	FastRetrieval       bool          `json:"fastRetrieval"`
	AuctionID           auction.ID    `json:"auctionID"`
	BidID               auction.BidID `json:"bidID"`
	Status              Status        `json:"status"`
	Executing           bool          `json:"executing"`
	ErrorCause          string        `json:"errorCause"`
	Retries             int           `json:"retries"`
	ProposalCid         string        `json:"proposalCid"`
	DealID              int64         `json:"dealID"`
	DealExpiration      uint64        `json:"dealExpiration"`
	DealMarketStatus    uint64        `json:"dealMarketStatus"`
	ReadyAt             time.Time     `json:"readyAt"`
	ID                  string        `json:"id"`
}

func (q *Queries) UpdateAuctionDeal(ctx context.Context, arg UpdateAuctionDealParams) (int64, error) {
	result, err := q.exec(ctx, q.updateAuctionDealStmt, updateAuctionDeal,
		arg.AuctionDataID,
		arg.StorageProviderID,
		arg.PricePerGibPerEpoch,
		arg.StartEpoch,
		arg.Verified,
		arg.FastRetrieval,
		arg.AuctionID,
		arg.BidID,
		arg.Status,
		arg.Executing,
		arg.ErrorCause,
		arg.Retries,
		arg.ProposalCid,
		arg.DealID,
		arg.DealExpiration,
		arg.DealMarketStatus,
		arg.ReadyAt,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
