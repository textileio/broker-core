// Code generated by sqlc. DO NOT EDIT.

package db

import (
	"context"
	"database/sql"
	"fmt"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

func Prepare(ctx context.Context, db DBTX) (*Queries, error) {
	q := Queries{db: db}
	var err error
	if q.batchUpdateStorageRequestsStmt, err = db.PrepareContext(ctx, batchUpdateStorageRequests); err != nil {
		return nil, fmt.Errorf("error preparing query BatchUpdateStorageRequests: %w", err)
	}
	if q.createBatchStmt, err = db.PrepareContext(ctx, createBatch); err != nil {
		return nil, fmt.Errorf("error preparing query CreateBatch: %w", err)
	}
	if q.createMinerDealStmt, err = db.PrepareContext(ctx, createMinerDeal); err != nil {
		return nil, fmt.Errorf("error preparing query CreateMinerDeal: %w", err)
	}
	if q.createStorageRequestStmt, err = db.PrepareContext(ctx, createStorageRequest); err != nil {
		return nil, fmt.Errorf("error preparing query CreateStorageRequest: %w", err)
	}
	if q.createUnpinJobStmt, err = db.PrepareContext(ctx, createUnpinJob); err != nil {
		return nil, fmt.Errorf("error preparing query CreateUnpinJob: %w", err)
	}
	if q.deleteExecutingUnpinJobStmt, err = db.PrepareContext(ctx, deleteExecutingUnpinJob); err != nil {
		return nil, fmt.Errorf("error preparing query DeleteExecutingUnpinJob: %w", err)
	}
	if q.getBatchStmt, err = db.PrepareContext(ctx, getBatch); err != nil {
		return nil, fmt.Errorf("error preparing query GetBatch: %w", err)
	}
	if q.getMinerDealsStmt, err = db.PrepareContext(ctx, getMinerDeals); err != nil {
		return nil, fmt.Errorf("error preparing query GetMinerDeals: %w", err)
	}
	if q.getStorageRequestStmt, err = db.PrepareContext(ctx, getStorageRequest); err != nil {
		return nil, fmt.Errorf("error preparing query GetStorageRequest: %w", err)
	}
	if q.getStorageRequestIDsStmt, err = db.PrepareContext(ctx, getStorageRequestIDs); err != nil {
		return nil, fmt.Errorf("error preparing query GetStorageRequestIDs: %w", err)
	}
	if q.getStorageRequestsStmt, err = db.PrepareContext(ctx, getStorageRequests); err != nil {
		return nil, fmt.Errorf("error preparing query GetStorageRequests: %w", err)
	}
	if q.nextUnpinJobStmt, err = db.PrepareContext(ctx, nextUnpinJob); err != nil {
		return nil, fmt.Errorf("error preparing query NextUnpinJob: %w", err)
	}
	if q.rebatchStorageRequestsStmt, err = db.PrepareContext(ctx, rebatchStorageRequests); err != nil {
		return nil, fmt.Errorf("error preparing query RebatchStorageRequests: %w", err)
	}
	if q.unpinJobToPendingStmt, err = db.PrepareContext(ctx, unpinJobToPending); err != nil {
		return nil, fmt.Errorf("error preparing query UnpinJobToPending: %w", err)
	}
	if q.updateBatchStmt, err = db.PrepareContext(ctx, updateBatch); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateBatch: %w", err)
	}
	if q.updateBatchStatusStmt, err = db.PrepareContext(ctx, updateBatchStatus); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateBatchStatus: %w", err)
	}
	if q.updateBatchStatusAndErrorStmt, err = db.PrepareContext(ctx, updateBatchStatusAndError); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateBatchStatusAndError: %w", err)
	}
	if q.updateMinerDealsStmt, err = db.PrepareContext(ctx, updateMinerDeals); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateMinerDeals: %w", err)
	}
	if q.updateStorageRequestsStatusStmt, err = db.PrepareContext(ctx, updateStorageRequestsStatus); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateStorageRequestsStatus: %w", err)
	}
	return &q, nil
}

func (q *Queries) Close() error {
	var err error
	if q.batchUpdateStorageRequestsStmt != nil {
		if cerr := q.batchUpdateStorageRequestsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing batchUpdateStorageRequestsStmt: %w", cerr)
		}
	}
	if q.createBatchStmt != nil {
		if cerr := q.createBatchStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createBatchStmt: %w", cerr)
		}
	}
	if q.createMinerDealStmt != nil {
		if cerr := q.createMinerDealStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createMinerDealStmt: %w", cerr)
		}
	}
	if q.createStorageRequestStmt != nil {
		if cerr := q.createStorageRequestStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createStorageRequestStmt: %w", cerr)
		}
	}
	if q.createUnpinJobStmt != nil {
		if cerr := q.createUnpinJobStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createUnpinJobStmt: %w", cerr)
		}
	}
	if q.deleteExecutingUnpinJobStmt != nil {
		if cerr := q.deleteExecutingUnpinJobStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deleteExecutingUnpinJobStmt: %w", cerr)
		}
	}
	if q.getBatchStmt != nil {
		if cerr := q.getBatchStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getBatchStmt: %w", cerr)
		}
	}
	if q.getMinerDealsStmt != nil {
		if cerr := q.getMinerDealsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getMinerDealsStmt: %w", cerr)
		}
	}
	if q.getStorageRequestStmt != nil {
		if cerr := q.getStorageRequestStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getStorageRequestStmt: %w", cerr)
		}
	}
	if q.getStorageRequestIDsStmt != nil {
		if cerr := q.getStorageRequestIDsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getStorageRequestIDsStmt: %w", cerr)
		}
	}
	if q.getStorageRequestsStmt != nil {
		if cerr := q.getStorageRequestsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getStorageRequestsStmt: %w", cerr)
		}
	}
	if q.nextUnpinJobStmt != nil {
		if cerr := q.nextUnpinJobStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing nextUnpinJobStmt: %w", cerr)
		}
	}
	if q.rebatchStorageRequestsStmt != nil {
		if cerr := q.rebatchStorageRequestsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing rebatchStorageRequestsStmt: %w", cerr)
		}
	}
	if q.unpinJobToPendingStmt != nil {
		if cerr := q.unpinJobToPendingStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing unpinJobToPendingStmt: %w", cerr)
		}
	}
	if q.updateBatchStmt != nil {
		if cerr := q.updateBatchStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateBatchStmt: %w", cerr)
		}
	}
	if q.updateBatchStatusStmt != nil {
		if cerr := q.updateBatchStatusStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateBatchStatusStmt: %w", cerr)
		}
	}
	if q.updateBatchStatusAndErrorStmt != nil {
		if cerr := q.updateBatchStatusAndErrorStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateBatchStatusAndErrorStmt: %w", cerr)
		}
	}
	if q.updateMinerDealsStmt != nil {
		if cerr := q.updateMinerDealsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateMinerDealsStmt: %w", cerr)
		}
	}
	if q.updateStorageRequestsStatusStmt != nil {
		if cerr := q.updateStorageRequestsStatusStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateStorageRequestsStatusStmt: %w", cerr)
		}
	}
	return err
}

func (q *Queries) exec(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (sql.Result, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).ExecContext(ctx, args...)
	case stmt != nil:
		return stmt.ExecContext(ctx, args...)
	default:
		return q.db.ExecContext(ctx, query, args...)
	}
}

func (q *Queries) query(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (*sql.Rows, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryContext(ctx, args...)
	default:
		return q.db.QueryContext(ctx, query, args...)
	}
}

func (q *Queries) queryRow(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) *sql.Row {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryRowContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryRowContext(ctx, args...)
	default:
		return q.db.QueryRowContext(ctx, query, args...)
	}
}

type Queries struct {
	db                              DBTX
	tx                              *sql.Tx
	batchUpdateStorageRequestsStmt  *sql.Stmt
	createBatchStmt                 *sql.Stmt
	createMinerDealStmt             *sql.Stmt
	createStorageRequestStmt        *sql.Stmt
	createUnpinJobStmt              *sql.Stmt
	deleteExecutingUnpinJobStmt     *sql.Stmt
	getBatchStmt                    *sql.Stmt
	getMinerDealsStmt               *sql.Stmt
	getStorageRequestStmt           *sql.Stmt
	getStorageRequestIDsStmt        *sql.Stmt
	getStorageRequestsStmt          *sql.Stmt
	nextUnpinJobStmt                *sql.Stmt
	rebatchStorageRequestsStmt      *sql.Stmt
	unpinJobToPendingStmt           *sql.Stmt
	updateBatchStmt                 *sql.Stmt
	updateBatchStatusStmt           *sql.Stmt
	updateBatchStatusAndErrorStmt   *sql.Stmt
	updateMinerDealsStmt            *sql.Stmt
	updateStorageRequestsStatusStmt *sql.Stmt
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db:                              tx,
		tx:                              tx,
		batchUpdateStorageRequestsStmt:  q.batchUpdateStorageRequestsStmt,
		createBatchStmt:                 q.createBatchStmt,
		createMinerDealStmt:             q.createMinerDealStmt,
		createStorageRequestStmt:        q.createStorageRequestStmt,
		createUnpinJobStmt:              q.createUnpinJobStmt,
		deleteExecutingUnpinJobStmt:     q.deleteExecutingUnpinJobStmt,
		getBatchStmt:                    q.getBatchStmt,
		getMinerDealsStmt:               q.getMinerDealsStmt,
		getStorageRequestStmt:           q.getStorageRequestStmt,
		getStorageRequestIDsStmt:        q.getStorageRequestIDsStmt,
		getStorageRequestsStmt:          q.getStorageRequestsStmt,
		nextUnpinJobStmt:                q.nextUnpinJobStmt,
		rebatchStorageRequestsStmt:      q.rebatchStorageRequestsStmt,
		unpinJobToPendingStmt:           q.unpinJobToPendingStmt,
		updateBatchStmt:                 q.updateBatchStmt,
		updateBatchStatusStmt:           q.updateBatchStatusStmt,
		updateBatchStatusAndErrorStmt:   q.updateBatchStatusAndErrorStmt,
		updateMinerDealsStmt:            q.updateMinerDealsStmt,
		updateStorageRequestsStatusStmt: q.updateStorageRequestsStatusStmt,
	}
}
