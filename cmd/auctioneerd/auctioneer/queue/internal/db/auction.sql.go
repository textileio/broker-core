// Code generated by sqlc. DO NOT EDIT.
// source: auction.sql

package db

import (
	"context"

	"github.com/lib/pq"
	"github.com/textileio/bidbot/lib/auction"
	"github.com/textileio/broker-core/broker"
)

const createAuction = `-- name: CreateAuction :exec
INSERT INTO auctions(
    id,
    batch_id,
    deal_size,
    deal_duration,
    deal_replication,
    deal_verified,
    fil_epoch_deadline,
    excluded_storage_providers,
    providers,
    payload_cid,
    car_url,
    car_ipfs_cid,
    car_ipfs_addrs,
    status,
    duration,
    client_address
    ) VALUES (
      $1,
      $2,
      $3,
      $4,
      $5,
      $6,
      $7,
      $8,
      $9,
      $10,
      $11,
      $12,
      $13,
      $14,
      $15,
      $16)
`

type CreateAuctionParams struct {
	ID                       auction.ID           `json:"id"`
	BatchID                  broker.BatchID       `json:"batchID"`
	DealSize                 int64                `json:"dealSize"`
	DealDuration             uint64               `json:"dealDuration"`
	DealReplication          int32                `json:"dealReplication"`
	DealVerified             bool                 `json:"dealVerified"`
	FilEpochDeadline         uint64               `json:"filEpochDeadline"`
	ExcludedStorageProviders []string             `json:"excludedStorageProviders"`
	Providers                []string             `json:"providers"`
	PayloadCid               string               `json:"payloadCid"`
	CarUrl                   string               `json:"carUrl"`
	CarIpfsCid               string               `json:"carIpfsCid"`
	CarIpfsAddrs             []string             `json:"carIpfsAddrs"`
	Status                   broker.AuctionStatus `json:"status"`
	Duration                 int64                `json:"duration"`
	ClientAddress            string               `json:"clientAddress"`
}

func (q *Queries) CreateAuction(ctx context.Context, arg CreateAuctionParams) error {
	_, err := q.exec(ctx, q.createAuctionStmt, createAuction,
		arg.ID,
		arg.BatchID,
		arg.DealSize,
		arg.DealDuration,
		arg.DealReplication,
		arg.DealVerified,
		arg.FilEpochDeadline,
		pq.Array(arg.ExcludedStorageProviders),
		pq.Array(arg.Providers),
		arg.PayloadCid,
		arg.CarUrl,
		arg.CarIpfsCid,
		pq.Array(arg.CarIpfsAddrs),
		arg.Status,
		arg.Duration,
		arg.ClientAddress,
	)
	return err
}

const getAuction = `-- name: GetAuction :one
SELECT id, batch_id, deal_size, deal_duration, deal_replication, deal_verified, fil_epoch_deadline, excluded_storage_providers, payload_cid, car_url, car_ipfs_cid, car_ipfs_addrs, status, error_cause, duration, started_at, updated_at, client_address, providers FROM auctions
WHERE id = $1
`

func (q *Queries) GetAuction(ctx context.Context, id auction.ID) (Auction, error) {
	row := q.queryRow(ctx, q.getAuctionStmt, getAuction, id)
	var i Auction
	err := row.Scan(
		&i.ID,
		&i.BatchID,
		&i.DealSize,
		&i.DealDuration,
		&i.DealReplication,
		&i.DealVerified,
		&i.FilEpochDeadline,
		pq.Array(&i.ExcludedStorageProviders),
		&i.PayloadCid,
		&i.CarUrl,
		&i.CarIpfsCid,
		pq.Array(&i.CarIpfsAddrs),
		&i.Status,
		&i.ErrorCause,
		&i.Duration,
		&i.StartedAt,
		&i.UpdatedAt,
		&i.ClientAddress,
		pq.Array(&i.Providers),
	)
	return i, err
}

const getNextReadyToExecute = `-- name: GetNextReadyToExecute :one
SELECT id, batch_id, deal_size, deal_duration, deal_replication, deal_verified, fil_epoch_deadline, excluded_storage_providers, payload_cid, car_url, car_ipfs_cid, car_ipfs_addrs, status, error_cause, duration, started_at, updated_at, client_address, providers FROM auctions
WHERE status = 'queued' OR
(status = 'started' AND extract(epoch from current_timestamp - updated_at) > $1::bigint)
ORDER BY fil_epoch_deadline ASC
FOR UPDATE SKIP LOCKED
LIMIT 1
`

func (q *Queries) GetNextReadyToExecute(ctx context.Context, stuckSeconds int64) (Auction, error) {
	row := q.queryRow(ctx, q.getNextReadyToExecuteStmt, getNextReadyToExecute, stuckSeconds)
	var i Auction
	err := row.Scan(
		&i.ID,
		&i.BatchID,
		&i.DealSize,
		&i.DealDuration,
		&i.DealReplication,
		&i.DealVerified,
		&i.FilEpochDeadline,
		pq.Array(&i.ExcludedStorageProviders),
		&i.PayloadCid,
		&i.CarUrl,
		&i.CarIpfsCid,
		pq.Array(&i.CarIpfsAddrs),
		&i.Status,
		&i.ErrorCause,
		&i.Duration,
		&i.StartedAt,
		&i.UpdatedAt,
		&i.ClientAddress,
		pq.Array(&i.Providers),
	)
	return i, err
}

const updateAuctionStatusAndError = `-- name: UpdateAuctionStatusAndError :exec
UPDATE auctions
SET status = $2, error_cause = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateAuctionStatusAndErrorParams struct {
	ID         auction.ID           `json:"id"`
	Status     broker.AuctionStatus `json:"status"`
	ErrorCause string               `json:"errorCause"`
}

func (q *Queries) UpdateAuctionStatusAndError(ctx context.Context, arg UpdateAuctionStatusAndErrorParams) error {
	_, err := q.exec(ctx, q.updateAuctionStatusAndErrorStmt, updateAuctionStatusAndError, arg.ID, arg.Status, arg.ErrorCause)
	return err
}
